#### 数据库的三范式

[参考链接](https://blog.csdn.net/qingking520/article/details/52937728)

##### 数据库范式

- 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。
- 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。
- 范式越高，冗余最低，一般到三范式，再往上，表越多，可能导致查询效率下降。所以有时为了提高运行效率，可以让数据冗余(反三范式，一般某个数据经常被访问时，比如数据表里存放了语文数学英语成绩，但是如果在某个时间经常要得到它的总分，每次都要进行计算会降低性能，可以加上总分这个冗余字段)。
- 后面的范式是在满足前面范式的基础上，比如满足第二范式的一定满足第一范式。

---

##### 第一范式 （1NF）：确保每一列的原子性

如果每一列的数据，都是不可再分的最小数据单元，则满足第一范式。

| id   | 地址     |
| ---- | -------- |
| 1    | 中国广东 |
| 2    | 中国南昌 |

上面的表就不满足第一范式，我们可以继续拆分

| id   | 国家 | 省份 |
| ---- | ---- | ---- |
| 1    | 中国 | 广东 |
| 2    | 中国 | 南昌 |

但是具体地址到底要不要拆分 还要看具体情形，比如看看将来会不会按国家或者省市进行分类汇总或者排序，如果需要，最好就拆，如果不需要而仅仅起字符串的作用，可以不拆，操作起来更方便。 

---

##### 第二范式（2NF）：非键字段必须依赖于键字段

==第二范式要满足第一范式==

如果一个关系满足1NF，并且除了主键以外的其它列，都完全依赖与该主键（不能部分依赖），则满足二范式(2NF)，第二范式要求每个表只描述一件事。 

| 订单编号（主键） | 产品编号（主键） | 订购日期  | 价格 |
| ---------------- | ---------------- | --------- | ---- |
| 001              | a001             | 2017-12-1 | 35   |

上面的表，订单编号和产品编号是主键，订购日期完全依赖于主键，但是价格不完全依赖主键（价格部分依赖主键）。所以我们可以对原表重新设计。

==订单表==

| 订单编号（主键） | 产品编号（主键） | 订购日期  |
| ---------------- | ---------------- | --------- |
| 001              | a001             | 2017-12-1 |

==产品表==

| 产品编号（主键） | 价格 |
| ---------------- | ---- |
| a001             | 45   |

##### 第三范式（3NF）：非主键列必须直接依赖于主键，不能存在传递依赖 

首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 

==考虑一个订单表==

| 订单编号（主键） | 订单时间 | 客户编号 | 客户名称 | 客户地址 |
| ---------------- | -------- | -------- | -------- | -------- |
|                  |          |          |          |          |

上表中，主键是订单编号，非主键属性完全依赖于主键，所以满足第二范式。但是客户名称和客户地址直接依赖于客户编号，所以这个存在传递依赖。所以这里不满足第三范式。

==我们可以进行拆分==

| 订单编号 | 订单时间 | 客户编号 |
| -------- | -------- | -------- |
|          |          |          |

| 客户编号 | 客户名称 | 客户地址 |
| -------- | -------- | -------- |
|          |          |          |

