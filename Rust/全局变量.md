#### 全局变量

##### 原生 `static` 只能作用于在编译时，可以确定的值。

```rust
static X: i32 = 16;
static mut Y: i32 = 1;


fn main() {
    println!("{}", X);
		
  	// 使用可变变量，需要使用 unsafe
    unsafe {
        Y = 2;
        println!("{}", Y);
    }
}

```

---

##### `lazy_static`  可以作用于任何变量

```rust
#[macro_use]
extern crate lazy_static;
use std::sync::Mutex;

// lazy_static 可以用在任何的变量上
lazy_static! {
    static ref ARRAY: Mutex<Vec<u8>> = Mutex::new(vec![]);
}



fn main() {
    ARRAY.lock().unwrap().push(1);
    println!("called {}", ARRAY.lock().unwrap().len());
}

```

---

##### `once_cell` 更方便

```rust
extern crate once_cell;

use once_cell::sync;
use once_cell::unsync;
use std::sync::Mutex;
use std::collections::HashMap;


# 如果需要改变则使用 Mutex ，不需要变，就不需要 Mutex
static USER: sync::Lazy<Mutex<HashMap<&str, &str>>> = sync::Lazy::new(|| {
    let mut m = HashMap::new();
    m.insert("name", "stefanlei");
    m.insert("age", "18");
    return Mutex::new(m);
});


fn main() {
    println!("{:?}", USER.lock().unwrap().get("name").unwrap());
}

```

---



##### 使用 once_cell 实现数据库单例模式

`db.rs`

```rust
extern crate mysql;
extern crate once_cell;

use mysql::{PooledConn, Opts, Pool};
use std::sync::Mutex;
use once_cell::sync::Lazy;


// 静态全局变量 POOL ，后面就不会再次创建了，而是使用现有的。
pub static POOL: Lazy<Pool> = Lazy::new(|| {
    let url = "mysql://username:passowrd@localhost:3306/test";
    let opts = Opts::from_url(url).unwrap();
    // 指定连接池大小
    let pool = Pool::new_manual(10, 20, opts).unwrap();
    return pool;
});

```

`main.rs`

```rust
mod db;

fn main(){
   let mut conn = db::POOL.get_conn().unwrap();
}
```

